try, catch, and rescue
  # Elixir has three error mechanisms: errors, throws, and exits.

Errors
  # Errors (or exceptions) are used when exceptional things happen in your code.
    :foo + 1
      ** (ArithmeticError) bad argument in arithmetic expression
      :erlang.+(:foo, 1)
  # A runtime error can be generated at any time by raising.
    raise "oops"                                                            #=> ** (RuntimeError) oops
  # Other errors can be generated by raising passing the error name and a list of keyword arguments.
    raise ArgumentError, message: "invalid argument foo"                    #=> ** (ArgumentError) invalid argument foo
  # You can also define your own errors by creating a module and using the defexception construction that it contains. In this way, you will create an error with the same name as the module in which it is defined.
    defmodule MyError do
      defexception message: "default message"
    end
    raise MyError                                                           #=> ** (MyError) default message
    raise MyError, message: "custom message"                                #=> ** (MyError) custom message
  # Errors can be rescued using the try / rescue construct.
    try do
      raise "oops"
    rescue
        e in RuntimeError -> e
    end                                                                   #=> %RuntimeError{message: "oops"}
  # If you don't have any use for the exception, you don't have to pass a variable to rescue.
    try do
      raise "oops"
    rescue
        RuntimeError -> "Error!"
    end                                                                   #=> "Error!"
  # In practice, Elixir developers rarely use the try / rescue construct.
  # many languages would force you to rescue an error when a file cannot be opened properly. Instead, Elixir provides a File.read function that returns a tuple containing information about whether the file was successfully opened.
    File.read("hello")                                                    #=> {:error, :enoent}
    File.write("hello", "world")                                          #=> :ok
    File.read("hello")                                                    #=> {:ok, "world"}
  # There is no try / rescue here. In case you want to handle multiple results of opening a file, you can use pattern matching using the case construction.
    case File.read("hello") do
      {:ok, body} -> IO.puts("Success: #{body}")
      {:error, reason} -> IO.puts("Error: #{reason}")
    end
  # For cases where you expect a file to exist you can use File.read!
    File.read!("unknown")            #=> ** (File.Error) could not read file unknown: no such file or directory (elixir) lib/file.ex:272: File.read!/1

Reraise
  # While we generally avoid using try / rescueen Elixir, one situation where we may want to use such constructs is for observability / monitoring.
    try do
      ... some code ...
    rescue
      e ->
        Logger.error(Exception.format(:error, e, __STACKTRACE__))
        reraise e, __STACKTRACE__
    end
  # Here the exception is rescued, registered and then generated again. the __STACKTRACE__ construct is used both when formatting the exception and when rebuilding.

Throws
  # In Elixir, a value can be cast and then captured. throwy catches are reserved for situations where it is not possible to retrieve a value unless throwy catch is used.
    try do
      Enum.each(-50..50, fn(x) ->
        if rem(x, 13) == 0, do: throw(x)
      end)
      "Got nothing"
    catch
      x -> "Got #{x}"
    end                                                                   #=> "Got -39"
  # Given Enum providing a proper API, in practice Enum.find / 2 is the way to go.
    Enum.find(-50..50, &(rem(&1, 13) == 0))                               #=> -39

Exits
  # All Elixir code runs within processes that communicate with each other.
  # When a process dies from "natural causes", it sends an exit signal.
  # A process can also die by explicitly sending an exit signal.
    spawn_link(fn -> exit(1) end)                                         #=> ** (EXIT from #PID<0.56.0>) evaluator process exited with reason: 1
  # exit can also be "caught" using try / catch.
    try do
      exit("I am exiting")
    catch
      :exit, _ -> "not really"
    end                                                                   #=> "not really"

After
  # Sometimes it is necessary to ensure that a resource is cleaned up after some action that could generate an error.
    {:ok, file} = File.open("sample", [:utf8, :write])
    try do
      IO.write(file, "olÃ¡")
      raise "oops, something went wrong"
    after
      File.close(file)
    end                                                                   #=> ** (RuntimeError) oops, something went wrong
  # The afterclause will be executed regardless of whether the tested block succeeds or not.
  # Sometimes you may want to wrap the entire body of a function in a try construct to ensure that some code is executed afterwards. Elixir allows you to skip the try line.
    defmodule RunAfter do
      def without_even_trying do
        raise "oops"
      after
        IO.puts "cleaning up!"
      end
    end
    RunAfter.without_even_trying                                           #=> cleaning up! ** (RuntimeError) oops
  # lixir will automatically wrap the body of the function in a try whenever an after, rescue, or catch is specified.

Else
  # If an elseblock is present, it will match the results of the tryblock as long as the tryblock ends without a throw or error.
    x = 2                                                                  #=> 2
    try do
      1 / x
    rescue
      ArithmeticError ->
      :infinity
    else
      y when y < 1 and y > -1 ->
        :small
      _ ->
        :large
    end                                                                     #=> :small
  # Exceptions in the else block are not caught. If no pattern within the elseblock matches, an exception will be thrown; this exception is not caught by the current try / catch / rescue / after block.

Variables scope
  # This code is invalid.
    try do
      raise "fail"
      what_happened = :did_not_raise
    rescue
      _ -> what_happened = :rescued
    end
    what_happened                                                            #=> ** (RuntimeError) undefined function: what_happened/0
  # variables defined in try's do block are also not available inside rescue / after / else. This is because the trybloque can fail at any time.
  # This code is valid instead of the previous one.
    what_happened =
      try do
        raise "fail"
        :did_not_raise
      rescue
         _ -> :rescued
      end
